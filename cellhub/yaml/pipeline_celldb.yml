database:
    # database location and name
    url: sqlite:///./celldb.dir/csvdb

# compute resource options
# ------------------------
resources:
    # job memory for tasks; use this in combination with nslots
    # if no slots with memory pre-assigned; 'none' | e.g. 16G (x nslots)
    job_memory: None
    # number of job threads/slots
    threads: 1

table:

    # The location of the library metadata table. It is
    # automatically generated by pipeline_cellranger_multi.py.
    # It contains information
    # about the indexes, genome used, sequencing ID etc
    library:

      # the name of the table in the database
      name: library

      # either:
      # (1) the full path for single tables
      # or
      # (2) the path to the folder for
      # per library/sample tables
      path: cellranger.multi.dir/libraries.tsv

      # per-library/per-sample tables
      # must be located in a common directory and
      # have the name structure
      # library_id.tsv(.gz) | sample_id.tsv(.gz)
      glob: None

      # the field that will be filled with the file name
      # (minus suffix) when concatenating tables
      id_type: None

      # index columns
      # a comma separated list of columns which will be indexed
      index: library_id

      # the fields which will be added to the final table
      final_fields: "*"

    # This is a required, user supplied table. It contains:
    #
    # (1) the mapping of sample_id to library_id
    # (2) sample metadata fields as appropriate such as
    #     condition, genotype, replicate etc
    # (3) the mapping of sample_ids to demultiplexing IDs
    #     as/if needed for multiplexed experiments.
    sample:
      name: sample
      path: sample_metadata_authors.tsv
      index: library_id,sample_id
      final_fields: "*"

    # The location of the scrublet output directory
    # output of the pipeline_cell_qc.py
    # scrublet: scrublet.dir
    gex_scrublet:
      name: gex_scrublet
      path: api/cell.qc/scrublet/filtered
      glob: "*.tsv.gz"
      id_type: library_id
      index: barcode_id
      final_fields: "*"

    # location of the qcmetrics data directory
    # output of the pipeline_cell_qc.py
    # qcmetrics: qcmetrics.dir
    gex_qcmetrics:
      name: gex_qcmetrics
      path: api/cell.qc/qcmetrics/filtered
      glob: "*.tsv.gz"
      id_type: library_id
      index: barcode_id
      final_fields: "*"

    # location of the gmm_demux results
    # output of the pipeline_dehasj.py
    gmm_demux:
      active: False
      name: gmm_demux
      path: api/dehash/gmm.demux/filtered
      glob: "*.tsv.gz"
      id_type: library_id
      index: barcode_id
      final_fields: "*"

    # location for ADT qc metric
    # output of the pipeline_cell_qc.py
    adt_qcmetrics:
      active: False
      name: gex_scrublet
      path: scrublet.dir
      glob: "*.tsv.gz"
      id_type: library_id
      index: barcode_id
      final_fields: "*"

    # location of external cell-metadata
    cell_meta:
      active: False
      name: cell_meta
      path: cell_metadata_authors.tsv.gz
      glob: "*.tsv.gz"
      id_type: library_id
      index: barcode_id
      final_fields: "*"

    final:
      sql_query: >-
        CREATE VIEW final AS
        SELECT s.*, qc.*, scrub.*
        FROM gex_qcmetrics qc
        LEFT JOIN sample s
        on qc.library_id = s.library_id
        LEFT JOIN gex_scrublet scrub
        ON qc.barcode_id = scrub.barcode_id;

     #final:
     # sql_query: >-
     #   CREATE VIEW final AS
     #   SELECT s.*, qc.*, scrub.*, cm.*
     #   FROM gex_qcmetrics qc
     #   LEFT JOIN sample s
     #   on qc.library_id = s.library_id
     #   LEFT JOIN gex_scrublet scrub
     #   ON qc.barcode_id = scrub.barcode_id
     #   LEFT JOIN cell_meta cm
     #   ON scrub.barcode_id = cm.barcode_id;

      # Query example for a hashed dataset.
      # *** note that the sample table is joined
      #     on library_id AND hto_id ***
      #
      # sql_query: >-
      #   CREATE VIEW final AS
      #   SELECT s.*, qc.*, scrub.*, gd.*
      #   FROM gex_qcmetrics qc
      #   LEFT JOIN gex_scrublet scrub
      #   ON qc.barcode_id = scrub.barcode_id
      #   LEFT JOIN gmm_demux gd
      #   ON qc.barcode_id = gd.barcode_id
      #   LEFT JOIN sample s
      #   on qc.library_id = s.library_id AND gd.gmm_call = s.hto_id;

virtual:
    # Build the database using virtual tables, if 0 then it will generate a non-virtual database
    active: 0
